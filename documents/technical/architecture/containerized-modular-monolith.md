# コンテナ化モジュラーモノリスアーキテクチャ設計

**文書番号**: ARCH-002  
**作成日**: 2025-03-21  
**最終更新日**: 2025-03-22  
**バージョン**: 1.0.1  
**ステータス**: 確定  
**関連文書**: 
- ARCH-001 (アーキテクチャ概要)
- DEC-001 (ディレクトリ構造設計)
- GUIDE-002 (開発環境セットアップ)

## 概要

この文書は、HugMeDoプロジェクトで採用するコンテナ化モジュラーモノリスアーキテクチャの詳細設計を定義します。このアーキテクチャは、水平スケーラビリティ、API駆動、回復力、コンテナ化の原則に基づき、開発の容易さと運用の効率性を両立させることを目的としています。

## バージョニング体系と開発フェーズ

HugMeDoプロジェクトは以下のバージョニング体系に従って段階的に開発を進めます：

- **v0.0.0**: 基盤構築フェーズ
  - コンテナ化モジュラーモノリスの基本構造の確立
  - Docker Compose設定
  - APIゲートウェイ
  - 認証・認可基盤
  - モニタリング・ロギング基盤

- **v0.0.0**: コアモジュール実装フェーズ
  - OHRモジュール（ビデオ通話）の基本実装
  - Chatモジュール（リアルタイムチャット）の基本実装
  - 基本的なダッシュボード統合
  - ユーザーロールに基づくアクセス制御

- **v0.0.0**: 機能強化フェーズ
  - OHRモジュールの拡張機能
  - Chatモジュールの拡張機能
  - モジュール間連携の強化
  - ユーザーインターフェースの改善

- **v0.0.0**: 統合・安定化フェーズ
  - システム全体の統合とテスト
  - パフォーマンス最適化
  - セキュリティ強化
  - CI/CDパイプラインの構築

- **v0.0.0**: 本番リリースフェーズ
  - AWS環境へのデプロイ
  - 運用体制の確立
  - 監視とアラートの設定

- **v0.0.0以降**: 拡張フェーズ
  - HALCAモジュール（メンタルヘルスチェック）
  - Hugmemoモジュール（医療記録管理）
  - 追加機能の実装

## コンテナ化モジュラーモノリスの原則

### 1. 水平スケーラビリティ（Horizontally scalable）

- 負荷に応じて水平にスケールアウト可能な設計
- ステートレスなコンポーネント設計
- 共有リソースへのアクセスの最適化

### 2. API駆動（API-driven）

- すべてのモジュール間の通信は明確に定義されたAPIを通じて行う
- 内部APIと外部APIの明確な分離
- バージョニングとバックワード互換性の確保

### 3. 回復力（Resilient）

- 障害に対する耐性を持つ設計
- 自動復旧メカニズムの実装
- 段階的な機能低下（Graceful Degradation）の実現

### 4. コンテナ化（Containerized）

- すべてのコンポーネントはDockerコンテナとして実装
- 環境間の一貫性の確保
- デプロイの簡素化と自動化

### 5. モジュラーモノリス（Modular Monolith）

- 単一のデプロイ単位としての全体設計
- 明確な責任分担と境界の定義
- 将来のマイクロサービス化を見据えた設計

## v0.0.0までの優先モジュール

v0.0.0までの開発では、以下の2つのコアモジュールに焦点を当てます：

### OHRモジュール（ビデオ通話）

- **目的**: 医療従事者と患者間のビデオ通話を実現
- **主要技術**: Amazon Chime SDK, WebRTC
- **主要機能**:
  - 1対1ビデオ通話
  - 画面共有
  - 通話録画
  - 待合室機能
- **ポート**: 40100

### Chatモジュール（リアルタイムチャット）

- **目的**: テキストベースのコミュニケーションを提供
- **主要技術**: Socket.IO, Redis
- **主要機能**:
  - リアルタイムメッセージング
  - メッセージ履歴
  - ファイル共有
  - 既読確認
- **ポート**: 40110

## v0.0.0以降の拡張モジュール

v0.0.0のリリース後、以下のモジュールを段階的に追加する予定です：

### HALCAモジュール（メンタルヘルスチェック）

- **目的**: 伊勢方言を用いたメンタルヘルスチェックを提供
- **主要技術**: NLP, 対話エンジン
- **ポート**: 40120

### Hugmemoモジュール（医療記録管理）

- **目的**: 医療記録の管理と共有
- **主要技術**: FHIR, セキュアストレージ
- **ポート**: 40130

## コンポーネント詳細

### 1. クライアント層

#### Webアプリケーション

- **技術スタック**: SvelteKit, TypeScript, TailwindCSS
- **責任**: 
  - ユーザーインターフェース
  - クライアントサイドのルーティング
  - 状態管理
  - APIクライアント

#### モバイルアプリケーション

- **技術スタック**: SvelteKit, TypeScript, TailwindCSS
- **責任**: 
  - モバイル最適化UI
  - オフライン対応
  - プッシュ通知
  - ネイティブ機能連携

### 2. 機能モジュール

#### API Gateway

- **技術スタック**: Nginx, Node.js
- **責任**: 
  - リクエストルーティング
  - 認証・認可の実装
  - レート制限
  - APIドキュメンテーション

#### OHRモジュール

- **技術スタック**: Node.js, WebRTC, Amazon Chime SDK
- **責任**: 
  - ビデオ通話セッション管理
  - 待合室機能
  - 画面共有
  - 通話録画

#### Chatモジュール

- **技術スタック**: Node.js, Socket.IO, Redis
- **責任**: 
  - リアルタイムメッセージング
  - メッセージ履歴管理
  - ファイル共有
  - 既読確認

### 3. 共有パッケージ

#### Core

- **技術スタック**: TypeScript
- **責任**: 
  - 認証・認可のインターフェースと型定義
  - API関連のユーティリティ
  - 共通型定義
  - エラーハンドリング

#### UI

- **技術スタック**: Svelte, TailwindCSS
- **責任**: 
  - 共通UIコンポーネント
  - テーマ管理
  - アクセシビリティ対応
  - レスポンシブデザイン

#### Utils

- **技術スタック**: TypeScript
- **責任**: 
  - 日付・時間処理
  - データ変換
  - バリデーション
  - ロギング

### 4. コンテナオーケストレーション

- **技術スタック**: Docker Compose
- **責任**: 
  - コンテナのライフサイクル管理
  - サービスディスカバリ
  - ヘルスチェック
  - スケーリング

### 5. 機能モジュール

各機能モジュールは独立したコンテナとして実装され、以下の構造を持ちます：

- **API層**: モジュールの外部インターフェース
- **ビジネスロジック層**: モジュール固有の処理
- **データアクセス層**: データベースとの連携
- **イベント処理**: 非同期処理とイベント発行/購読

#### APIゲートウェイモジュール (modules/api-gateway)

- **技術スタック**: Node.js, Express
- **責任**: 
  - APIエントリーポイント
  - 認証実装（Amazon Cognito連携）
  - ルーティング
  - レート制限

#### OHRモジュール (modules/ohr)

- **技術スタック**: Node.js, Amazon Chime SDK
- **責任**: 
  - ビデオ通話機能
  - 画面共有
  - 通話録画
  - 待合室機能

#### Chatモジュール (modules/chat)

- **技術スタック**: Node.js, Socket.IO
- **責任**: 
  - リアルタイムメッセージング
  - メッセージ履歴
  - ファイル共有
  - 既読確認

### 6. データ層

#### メインデータベース

- **技術スタック**: PostgreSQL
- **責任**: 
  - 構造化データの永続化
  - トランザクション処理
  - データの整合性確保

#### キャッシュ

- **技術スタック**: Redis
- **責任**: 
  - 頻繁にアクセスされるデータのキャッシュ
  - セッション管理
  - 一時データの保存

#### ファイルストレージ

- **技術スタック**: MinIO (開発環境), S3 (本番環境)
- **責任**: 
  - 非構造化データの保存
  - ファイルのバージョン管理
  - アクセス制御

#### 検索エンジン

- **技術スタック**: Elasticsearch
- **責任**: 
  - 全文検索
  - ログ分析
  - メトリクス保存

## コンテナ構成

### 開発環境

```yaml
# docker-compose.yml
version: '3.8'

services:
  # API Gateway
  api-gateway:
    build: ./infrastructure/docker/api-gateway
    ports:
      - "3000:80"
    depends_on:
      - core-service
      - ohr-module
      - chat-module
    networks:
      - hugmedo-network

  # コアサービス
  core-service:
    build: ./packages/core
    environment:
      - NODE_ENV=development
      - DB_HOST=postgres
      - REDIS_HOST=redis
    depends_on:
      - postgres
      - redis
    networks:
      - hugmedo-network

  # OHRモジュール
  ohr-module:
    build: ./modules/ohr
    environment:
      - NODE_ENV=development
      - CORE_SERVICE_URL=http://core-service:3001
    networks:
      - hugmedo-network

  # チャットモジュール
  chat-module:
    build: ./modules/chat
    environment:
      - NODE_ENV=development
      - CORE_SERVICE_URL=http://core-service:3001
    networks:
      - hugmedo-network

  # PostgreSQL
  postgres:
    image: postgres:14
    environment:
      - POSTGRES_USER=hugmedo
      - POSTGRES_PASSWORD=hugmedo
      - POSTGRES_DB=hugmedo
    volumes:
      - postgres-data:/var/lib/postgresql/data
    networks:
      - hugmedo-network

  # Redis
  redis:
    image: redis:7
    volumes:
      - redis-data:/data
    networks:
      - hugmedo-network

  # MinIO (S3互換ストレージ)
  minio:
    image: minio/minio
    command: server /data --console-address ":9001"
    environment:
      - MINIO_ROOT_USER=hugmedo
      - MINIO_ROOT_PASSWORD=hugmedo123
    ports:
      - "9000:9000"
      - "9001:9001"
    volumes:
      - minio-data:/data
    networks:
      - hugmedo-network

networks:
  hugmedo-network:

volumes:
  postgres-data:
  redis-data:
  minio-data:
```

### 本番環境

本番環境では、Docker Composeを使用しながらも、以下の点を強化します：

1. **複数レプリカの実行**
   - `docker-compose up --scale service=N`を使用
   - ステートレスサービスの水平スケーリング

2. **ロードバランシング**
   - Nginxを使用したリバースプロキシとロードバランシング
   - ヘルスチェックによる障害検出

3. **永続化ボリューム**
   - データの永続化と定期バックアップ
   - ボリュームの適切な管理

4. **セキュリティ強化**
   - 環境変数の安全な管理
   - ネットワークセグメンテーション
   - 最小権限の原則の適用

## モジュール間通信

### 同期通信（REST/GraphQL）

モジュール間の同期通信には、RESTまたはGraphQLを使用します：

```
ModuleA -> API Gateway -> ModuleB
```

例（REST）:
```
GET /api/v1/modules/ohr/meetings/123
```

例（GraphQL）:
```graphql
query {
  meeting(id: "123") {
    id
    title
    participants {
      id
      name
    }
  }
}
```

### 非同期通信（イベント駆動）

モジュール間の非同期通信には、イベントバスを使用します：

```
ModuleA -> Event Bus -> ModuleB, ModuleC, ...
```

例：
```javascript
// イベント発行
eventBus.publish('meeting.started', {
  meetingId: '123',
  startTime: new Date(),
  participants: ['user1', 'user2']
});

// イベント購読
eventBus.subscribe('meeting.started', (event) => {
  // イベント処理
});
```

## データ管理

### データモデル

各モジュールは独自のデータモデルを持ちますが、共通のエンティティ（ユーザー、組織など）は共有されます：

```
+----------------+       +----------------+
|  コアモジュール  |       |  OHRモジュール  |
|                |       |                |
| - ユーザー      |<----->| - ミーティング  |
| - 組織         |       | - 予約         |
| - 権限         |       | - 診療記録      |
+----------------+       +----------------+
        ^                        ^
        |                     |
+----------------+       +----------------+
| チャットモジュール |       | HALCAモジュール |
|                |       |                |
| - チャットルーム  |       | - スクリーニング |
| - メッセージ     |       | - 評価結果      |
| - 添付ファイル    |       | - レポート      |
+----------------+       +----------------+
```

### データアクセスパターン

1. **リポジトリパターン**
   - データアクセスロジックをリポジトリクラスにカプセル化
   - ビジネスロジックとデータアクセスの分離

2. **CQRS（Command Query Responsibility Segregation）**
   - 読み取り操作と書き込み操作の分離
   - 読み取り最適化（キャッシュ、読み取り専用レプリカ）

3. **データマッピング**
   - データベースモデルとドメインモデルの変換
   - TypeORMやPrismaなどのORMの使用

## 認証と認可

### 認証フロー

```
+-------------+       +-------------+       +-------------+
|  クライアント  |------>|  認証サービス  |------>|  トークン発行  |
+-------------+       +-------------+       +-------------+
                             |
                             v
                      +-------------+
                      | ユーザー情報取得 |
                      +-------------+
```

1. ユーザーがログイン情報を入力
2. 認証サービスが認証情報を検証
3. 認証成功時にJWTトークンを発行
4. クライアントは以降のリクエストにトークンを含める

### 認可モデル

```
+-------------+       +-------------+       +-------------+
|  リクエスト   |------>|  認可サービス  |------>|  許可/拒否   |
+-------------+       +-------------+       +-------------+
                             |
                             v
                      +-------------+
                      |  ポリシー評価  |
                      +-------------+
```

1. リクエストにJWTトークンを含める
2. 認可サービスがトークンを検証
3. ユーザーの権限とリソースのポリシーを評価
4. 評価結果に基づいてアクセスを許可または拒否

## エラーハンドリングと回復力

### エラーハンドリング戦略

1. **境界でのエラーハンドリング**
   - API層でのエラーキャッチと適切なレスポンス
   - クライアントへのエラー情報の適切な提供

2. **段階的な機能低下**
   - 一部機能の障害が全体に影響しないよう設計
   - 代替機能の提供

3. **リトライメカニズム**
   - 一時的な障害に対する自動リトライ
   - 指数バックオフとジッター

### 回復力パターン

1. **サーキットブレーカー**
   - 障害が検出された場合にサービス呼び出しを一時的に停止
   - 障害回復後の段階的な復旧

2. **バルクヘッド**
   - リソースプールの分離
   - 障害の影響範囲の限定

3. **タイムアウト**
   - すべての外部呼び出しに適切なタイムアウトを設定
   - デッドロックや無限待機の防止

## モニタリングとロギング

### モニタリング戦略

1. **ヘルスチェック**
   - 各サービスの稼働状態の監視
   - 自動復旧メカニズムのトリガー

2. **メトリクス収集**
   - システムメトリクス（CPU、メモリ、ディスク使用率）
   - アプリケーションメトリクス（リクエスト数、応答時間、エラー率）
   - ビジネスメトリクス（アクティブユーザー数、トランザクション数）

3. **アラート**
   - 閾値ベースのアラート
   - 異常検出ベースのアラート

### ロギング戦略

1. **構造化ロギング**
   - JSON形式でのログ出力
   - コンテキスト情報の付加

2. **ログレベル**
   - ERROR: 即時対応が必要なエラー
   - WARN: 潜在的な問題
   - INFO: 通常の操作情報
   - DEBUG: 開発・デバッグ用の詳細情報

3. **分散トレーシング**
   - リクエストの追跡
   - サービス間の依存関係の可視化

## デプロイ戦略

### CI/CD パイプライン

```
+-------------+       +-------------+       +-------------+
|  コード変更   |------>|  ビルド/テスト  |------>|  イメージ作成  |
+-------------+       +-------------+       +-------------+
                                                   |
                                                   v
+-------------+       +-------------+       +-------------+
| 本番デプロイ   |<------|  手動承認    |<------|  ステージング  |
+-------------+       +-------------+       +-------------+
```

1. コード変更（プルリクエスト）
2. 自動ビルドとテスト
3. Dockerイメージの作成と保存
4. ステージング環境へのデプロイと検証
5. 手動承認
6. 本番環境へのデプロイ

### Blue/Green デプロイメント

```
+-------------+       +-------------+
|  現行環境    |       |  新環境     |
| (Blue)      |       | (Green)     |
+-------------+       +-------------+
       ^                     ^
       |                     |
+-------------+       +-------------+
|  トラフィック  |------>|  テスト     |
+-------------+       +-------------+
```

1. 新バージョンを新環境（Green）にデプロイ
2. 新環境でテストを実施
3. テスト成功後、トラフィックを新環境に切り替え
4. 問題がなければ旧環境（Blue）を削除

## スケーリング戦略

### 水平スケーリング

```
+-------------+       +-------------+
|  負荷監視    |------>|  スケーリング  |
+-------------+       +-------------+
                             |
                             v
                      +-------------+
                      |  新インスタンス |
                      +-------------+
```

1. CPU使用率、メモリ使用率、リクエスト数などの負荷を監視
2. 閾値を超えた場合に自動的にインスタンス数を増加
3. 負荷が減少した場合にインスタンス数を減少

### データベーススケーリング

1. **読み取りレプリカ**
   - 読み取りクエリを複数のレプリカに分散
   - マスターデータベースの負荷軽減

2. **シャーディング**
   - データを複数のデータベースに分散
   - 大規模データセットの効率的な管理

3. **接続プーリング**
   - データベース接続の再利用
   - 接続オーバーヘッドの削減

## セキュリティ対策

### 多層防御

1. **ネットワークセキュリティ**
   - ファイアウォール
   - VPNアクセス
   - セグメンテーション

2. **アプリケーションセキュリティ**
   - 入力バリデーション
   - SQLインジェクション対策
   - XSS対策

3. **データセキュリティ**
   - 保存データの暗号化
   - 転送中のデータの暗号化
   - データマスキング

### セキュリティテスト

1. **静的解析**
   - コードスキャン
   - 依存関係の脆弱性チェック

2. **動的解析**
   - ペネトレーションテスト
   - ファジングテスト

3. **セキュリティレビュー**
   - コードレビュー
   - アーキテクチャレビュー

## 将来の拡張性

### マイクロサービス化

コンテナ化モジュラーモノリスアーキテクチャは、将来的なマイクロサービス化を見据えた設計になっています：

1. **モジュールの独立性**
   - 明確に定義されたAPIを通じた通信
   - 独立したデータストア

2. **段階的な移行**
   - 特定のモジュールから順次マイクロサービス化
   - 既存システムとの共存

3. **サービスメッシュの導入**
   - サービス間通信の管理
   - トラフィック制御とセキュリティ

### クラウドネイティブ化

1. **Kubernetes移行**
   - Docker Composeからの段階的な移行
   - クラスタ管理とオーケストレーション

2. **サーバーレスコンポーネント**
   - 特定の機能をサーバーレスに移行
   - イベント駆動型アーキテクチャの強化

3. **クラウドサービスの活用**
   - マネージドデータベース
   - マネージドキャッシュ
   - マネージドメッセージングサービス

## 変更履歴

### v0.0.0 (2025-03-21)
- 初期バージョン
- コンテナ化モジュラーモノリスアーキテクチャの定義
- コンポーネント構成の詳細化
- バージョニング体系と開発フェーズの追加
- v0.0.0までの優先モジュールの明記
- v0.0.0以降の拡張モジュールの追加
- 共有パッケージ・コアライブラリの配置を`packages/core`に設定
- API Gatewayを機能モジュールとして再配置